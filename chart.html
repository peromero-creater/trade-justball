<script>
    // ===== SWITCH TO LIVE LATER =====
    const DEMO = true; // keep true until Kenan sends URLs
    const API_HISTORY = 'https://YOUR_API/history';
    const WS_BARS     = 'wss://YOUR_API/ws/bars';
    const WS_DEPTH    = 'wss://YOUR_API/ws/depth';
    // =================================
  
    // URL params support
    const sp = new URLSearchParams(location.search);
    const symEl = document.getElementById('sym');
    const resEl = document.getElementById('res');
    if (sp.get('symbol')) symEl.value = sp.get('symbol').toUpperCase();
    if (sp.get('res')) resEl.value = sp.get('res');
  
    const statusEl = document.getElementById('status');
    const titleEl  = document.getElementById('title');
  
    // ----- Chart setup -----
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
      layout: { background:{type:'Solid', color:'#0f1115'}, textColor:'#d0d2d6' },
      grid: { vertLines:{color:'#1b1e26'}, horzLines:{color:'#1b1e26'} },
      timeScale: { timeVisible:true, secondsVisible:true },
    });
    const candle = chart.addCandlestickSeries();
    const vol = chart.addHistogramSeries({ priceScaleId: '' });
    chart.priceScale('').applyOptions({ scaleMargins:{ top:0.8, bottom:0 } });
  
    // ----- Helpers -----
    const msToSec = t => (t > 1e12 ? Math.floor(t/1000) : t);
    const fromUDF = j => j.t.map((t,i)=>({ time:t, open:+j.o[i], high:+j.h[i], low:+j.l[i], close:+j.c[i], volume:+j.v[i] }));
    const fromArr = a => a.map(b=>({ time:msToSec(b.time), open:+b.open, high:+b.high, low:+b.low, close:+b.close, volume:+b.volume }));
    const paintVol = bars => vol.setData(bars.map(b=>({ time:b.time, value:b.volume, color:b.close>=b.open?'#26a69a':'#ef5350' })));
    const stepOf = (res) => res==='1D'?86400 : res==='60'?3600 : res==='15'?900 : res==='5'?300 : 60;
  
    // We'll manage the latest bar ourselves (no private fields)
    let lastBar = null;
  
    // ----- DEMO generators -----
    function genHistory(symbol, res, hours=6){
      const step = stepOf(res);
      const to = Math.floor(Date.now()/1000);
      let t = Math.floor((to - hours*3600)/step)*step;
      let price = 64000, bars = [];
      while (t < to){
        const open = price;
        const close = open + (Math.random()*2-1)*30;
        const high = Math.max(open, close) + Math.random()*10;
        const low  = Math.min(open, close) - Math.random()*10;
        const volume = Math.abs(8 + (Math.random()-0.5)*3);
        bars.push({ time:t, open:+open.toFixed(2), high:+high.toFixed(2), low:+low.toFixed(2), close:+close.toFixed(2), volume:+volume.toFixed(4) });
        price = close; t += step;
      }
      return bars;
    }
    function genDepth(mid=64200){
      const bids = [], asks = [];
      for (let i=1;i<=10;i++){
        bids.push([+(mid - i*5).toFixed(2), +(0.2 + i*0.05).toFixed(4)]);
        asks.push([+(mid + i*5).toFixed(2), +(0.2 + i*0.05).toFixed(4)]);
      }
      return {bids, asks, ts: Math.floor(Date.now()/1000)};
    }
  
    // ----- Load history -----
    async function loadHistory(symbol, res){
      if (DEMO){
        const bars = genHistory(symbol, res, 6);
        candle.setData(bars);
        paintVol(bars);
        lastBar = bars[bars.length - 1] || null;
        statusEl.textContent = `demo: ${bars.length} bars`;
        return;
      }
      statusEl.textContent = 'loading...';
      const to = Math.floor(Date.now()/1000), from = to - 60*60*6;
      const url = `${API_HISTORY}?symbol=${encodeURIComponent(symbol)}&resolution=${res}&from=${from}&to=${to}`;
      const r = await fetch(url);
      const j = await r.json();
      const bars = (j && j.s==='ok' && Array.isArray(j.t)) ? fromUDF(j)
                 : Array.isArray(j) ? fromArr(j) : [];
      candle.setData(bars);
      paintVol(bars);
      lastBar = bars[bars.length - 1] || null;
      statusEl.textContent = `loaded ${bars.length} bars`;
    }
  
    // ----- Realtime bars -----
    let wsBars, demoBarTimer;
    function startBars(symbol, res){
      if (DEMO){
        clearInterval(demoBarTimer);
        const step = stepOf(res);
        demoBarTimer = setInterval(()=>{
          const now = Math.floor(Date.now()/1000);
          if (!lastBar || now - lastBar.time >= step){
            const open = lastBar ? lastBar.close : 64000;
            lastBar = { time: now - (now % step), open: open, high: open, low: open, close: open, volume: 0 };
          }
          const c = lastBar.close + (Math.random()*2-1)*6;
          lastBar.high = Math.max(lastBar.high, c);
          lastBar.low  = Math.min(lastBar.low, c);
          lastBar.close = +c.toFixed(2);
          lastBar.volume = +(lastBar.volume + Math.abs((Math.random()-0.5)*0.2)).toFixed(4);
  
          candle.update(lastBar);
          vol.update({ time:lastBar.time, value:lastBar.volume, color:lastBar.close>=lastBar.open?'#26a69a':'#ef5350' });
          statusEl.textContent = 'demo live';
        }, 1000);
        return;
      }
      // Live via WS
      if (wsBars) wsBars.close();
      wsBars = new WebSocket(`${WS_BARS}?symbol=${encodeURIComponent(symbol)}&res=${encodeURIComponent(res)}`);
      wsBars.onopen = () => statusEl.textContent = 'live';
      wsBars.onclose = () => statusEl.textContent = 'reconnecting...';
      wsBars.onerror = () => statusEl.textContent = 'ws error';
      wsBars.onmessage = ev=>{
        const m = JSON.parse(ev.data);
        const b = m.t ? { time:m.t, open:+m.o, high:+m.h, low:+m.l, close:+m.c, volume:+m.v }
                      : { time:msToSec(m.time), open:+m.open, high:+m.high, low:+m.low, close:+m.close, volume:+m.volume };
        candle.update(b);
        vol.update({ time:b.time, value:b.volume, color:b.close>=b.open?'#26a69a':'#ef5350' });
        lastBar = b;
      };
    }
  
    // ----- Depth panel -----
    let wsDepth, demoDepthTimer;
    function startDepth(symbol){
      const tbody = document.getElementById('depth-body');
      function render(book){
        const bids = (book.bids||[]).slice(0,10);
        const asks = (book.asks||[]).slice(0,10);
        const n = Math.max(bids.length, asks.length);
        const rows = [];
        for (let i=0;i<n;i++){
          const b = bids[i] || ['',''], a = asks[i] || ['',''];
          rows.push(`<tr><td class="bid">${b[0]??''}</td><td class="bid">${b[1]??''}</td><td></td><td class="ask">${a[0]??''}</td><td class="ask">${a[1]??''}</td></tr>`);
        }
        tbody.innerHTML = rows.join('');
      }
      if (DEMO){
        clearInterval(demoDepthTimer);
        demoDepthTimer = setInterval(()=>{
          const mid = 64200 + (Math.random()*2-1)*12;
          render(genDepth(mid));
        }, 1000);
        return;
      }
      if (wsDepth) wsDepth.close();
      wsDepth = new WebSocket(`${WS_DEPTH}?symbol=${encodeURIComponent(symbol)}`);
      wsDepth.onmessage = ev => render(JSON.parse(ev.data));
      wsDepth.onclose = () => setTimeout(()=>startDepth(symbol), 1000);
    }
  
    async function boot(symbol, res){
      titleEl.textContent = `Chart — ${symbol} (${res}) ${DEMO ? '• demo' : ''}`;
      await loadHistory(symbol, res);
      startBars(symbol, res);
      startDepth(symbol);
      history.replaceState(null,'',`?symbol=${encodeURIComponent(symbol)}&res=${encodeURIComponent(res)}`);
    }
  
    document.getElementById('apply').onclick = ()=>{
      boot(symEl.value.trim().toUpperCase(), resEl.value);
    };
  
    // First run
    boot(symEl.value.trim().toUpperCase(), resEl.value);
  </script>
  